import { register } from "@tokens-studio/sd-transforms";
import StyleDictionary from "style-dictionary";

// Tokens Studio transforms 등록
register(StyleDictionary, { excludeParentKeys: true });

/**
 * Tailwind v4 @theme 포맷
 * tokens-studio/sd-tailwindv4 레포지토리 패턴 기반
 */
StyleDictionary.registerFormat({
  name: "css/tailwind-theme",
  format({ dictionary, options = {} }) {
    const { outputReferences = true } = options;
    const numberOnly = /^-?\d+(\.\d+)?$/;
    const withPx = (value) => {
      if (typeof value === "number") return `${value}px`;
      if (typeof value !== "string") return value;
      if (value.startsWith("var(")) return `calc(${value} * 1px)`;
      if (numberOnly.test(value)) return `${value}px`;
      return value;
    };

    // 토큰을 카테고리별로 그룹화
    const tokensByCategory = {
      colors: [],
      spacing: [],
      gap: [],
      radius: [],
      borderWidth: [],
      typography: [],
      other: [],
    };

    dictionary.allTokens.forEach((token) => {
      const category = token.path[0]; // 첫 번째 경로 세그먼트로 분류
      const isSpacing = category === "layout" && token.path[1] === "spacing";
      const isGap = category === "layout" && token.path[1] === "gap";
      const isRadius = category === "shape" && token.path[1] === "radius";
      const isBorderWidth = category === "shape" && token.path[1] === "border-width";
      const needsLengthUnit = isSpacing || isGap || isRadius || isBorderWidth;

      // outputReferences 처리 - 토큰 값이 다른 토큰을 참조하는지 확인
      let value = token.value;
      if (
        outputReferences &&
        typeof token.original.value === "string" &&
        token.original.value.startsWith("{")
      ) {
        // 토큰 참조를 CSS 변수로 변환
        const refName = token.original.value.replace(/[{}]/g, "").replace(/\./g, "-");
        value = `var(--${refName})`;
      }
      if (needsLengthUnit) {
        value = withPx(value);
      }

      // Tailwind v4 호환 네이밍으로 변환
      let tokenName = token.name;
      if (tokenName.startsWith("layout-spacing-")) {
        tokenName = tokenName.replace("layout-spacing-", "spacing-");
      } else if (tokenName.startsWith("layout-gap-")) {
        tokenName = tokenName.replace("layout-gap-", "gap-");
      } else if (tokenName.startsWith("shape-radius-")) {
        tokenName = tokenName.replace("shape-radius-", "radius-");
      } else if (tokenName.startsWith("shape-border-width-")) {
        tokenName = tokenName.replace("shape-border-width-", "border-width-");
      }

      const cssVar = `  --${tokenName}: ${value};`;

      // 카테고리별로 분류
      if (category === "color") {
        tokensByCategory.colors.push(cssVar);
      } else if (isSpacing) {
        tokensByCategory.spacing.push(cssVar);
      } else if (isGap) {
        tokensByCategory.gap.push(cssVar);
      } else if (isRadius) {
        tokensByCategory.radius.push(cssVar);
      } else if (isBorderWidth) {
        tokensByCategory.borderWidth.push(cssVar);
      } else if (category === "typo") {
        tokensByCategory.typography.push(cssVar);
      } else {
        tokensByCategory.other.push(cssVar);
      }
    });

    // @theme 블록 생성
    const sections = [];

    if (tokensByCategory.colors.length > 0) {
      sections.push(
        `  /* Colors - Tailwind이 자동으로 bg-, text-, border- 유틸리티 생성 */\n${tokensByCategory.colors.join("\n")}`
      );
    }

    if (tokensByCategory.spacing.length > 0) {
      sections.push(
        `  /* Spacing - p-, m- 유틸리티 생성 */\n${tokensByCategory.spacing.join("\n")}`
      );
    }

    if (tokensByCategory.gap.length > 0) {
      sections.push(`  /* Gap - gap- 유틸리티 생성 */\n${tokensByCategory.gap.join("\n")}`);
    }

    if (tokensByCategory.radius.length > 0) {
      sections.push(
        `  /* Border Radius - rounded- 유틸리티 생성 */\n${tokensByCategory.radius.join("\n")}`
      );
    }

    if (tokensByCategory.borderWidth.length > 0) {
      sections.push(
        `  /* Border Width - border- 유틸리티 생성 */\n${tokensByCategory.borderWidth.join("\n")}`
      );
    }

    if (tokensByCategory.typography.length > 0) {
      sections.push(`  /* Typography */\n${tokensByCategory.typography.join("\n")}`);
    }

    if (tokensByCategory.other.length > 0) {
      sections.push(`  /* Other */\n${tokensByCategory.other.join("\n")}`);
    }

    return `/**
 * Tailwind v4 Design Tokens
 * Auto-generated by Style Dictionary
 * DO NOT EDIT DIRECTLY
 */

@theme inline {
${sections.join("\n\n")}
}
`;
  },
});

const sd = new StyleDictionary({
  source: ["token/**/*.json"],
  preprocessors: ["tokens-studio"], // Tokens Studio 전처리기

  platforms: {
    tailwind: {
      transformGroup: "tokens-studio",
      transforms: ["name/kebab"],
      buildPath: "src/styles/tokens/",
      files: [
        {
          destination: "theme.css",
          format: "css/tailwind-theme",
          options: {
            outputReferences: true,
          },
        },
      ],
    },
  },

  log: {
    warnings: "warn",
    verbosity: "verbose",
    errors: {
      brokenReferences: "console",
    },
  },
});

await sd.buildAllPlatforms();
